#!/usr/bin/env python
import rospy
import open_base
import math
from std_msgs.msg import Float32, Float64, Int32
from geometry_msgs.msg import Pose2D, Point

from math import pi
from open_base.srv import KinematicsInverse, KinematicsForward

class VelCommander:

    def __init__(self):
        # Velocity Commander Initialization
        # Description:
        #     Function initializes the velocity commander by creating the node,
        #     subscribers, and publishers. Additionally, the parameters and
        #     persistent variables are set/initialized to zero.

        rospy.init_node('vel_command_publisher')

        # Paramters
        self.circumference = pi * 0.101                     # meters
        self.linear_to_rot = 2 * pi / self.circumference    # rad / m
        self.command_timeout = 1.0                          # sec

        # create the publisher for each individual
        self.left_pub  = rospy.Publisher('left_joint_velocity_controller/command' , Float64, queue_size=10)
        self.back_pub  = rospy.Publisher('back_joint_velocity_controller/command' , Float64, queue_size=10)
        self.right_pub = rospy.Publisher('right_joint_velocity_controller/command', Float64, queue_size=10)

        # create the subscriber for the goal velocity
        self.vel_goal_sub = rospy.Subscriber('/robot_vel_goal', Pose2D, self.updateVels)

        # create the subscriber for the encoder_pulses_per_revolution
        self.left_enc_sub  = rospy.Subscriber( '/left_joint_velocity_controller/absolute_encoder_count', Int32, self.updateEnc_left)
        self.back_enc_sub  = rospy.Subscriber( '/back_joint_velocity_controller/absolute_encoder_count', Int32, self.updateEnc_back)
        self.right_enc_sub = rospy.Subscriber('/right_joint_velocity_controller/absolute_encoder_count', Int32, self.updatePos)

        # create publisher for position estimate
        self.pos_pub = rospy.Publisher('pos_estimate',Pose2D, queue_size=10)

        # create the caller to the inverse kinematics server
        self.ik_service_client = rospy.ServiceProxy('/kinematics_inverse_world', KinematicsInverse)

        # set/initialize persistent variables
        self.enc_init = [False, False, False]
        self.enc_prev = [0.0, 0.0, 0.0]
        self.enc_curr = [0.0, 0.0, 0.0]
        self.cmd_vel  = [0.0, 0.0, 0.0]
        self.last_command = rospy.get_time()
        self.d_pos_est = Pose2D(0,0,0)


    def updateEnc_left(self, msg):
        # Left Motor Encoder Callback
        # Description
        #     Function updates the internal memory of the left encoder counter.
        #     If the variable has not been initialized, the first value is assigned
        #     to both the previous and current encoder value.
        self.enc_curr[0] = msg.data
        if not self.enc_init[0]:
            self.enc_prev[0] = self.enc_curr[0]
            self.enc_init[0] = True

    def updateEnc_back(self, msg):
        # Back Motor Encoder Callback
        # Description
        #     Function updates the internal memory of the back encoder counter.
        #     If the variable has not been initialized, the first value is assigned
        #     to both the previous and current encoder value.
        self.enc_curr[1] = msg.data
        if not self.enc_init[1]:
            self.enc_prev[1] = self.enc_curr[1]
            self.enc_init[1] = True

    def updateVels(self, goal):
        resp = self.ik_service_client(goal)

        self.cmd_vel[0] = -resp.output.v_left  * self.linear_to_rot
        self.cmd_vel[1] = -resp.output.v_back  * self.linear_to_rot
        self.cmd_vel[2] = -resp.output.v_right * self.linear_to_rot

        self.last_command = rospy.get_time()

    def updatePos(self, msg):
        # Right Motor Encoder Callback
        # Description
        #     Function updates the internal memory of the right encoder counter.
        #     If the variable has not been initialized, the first value is assigned
        #     to both the previous and current encoder value. Additionally,
        #     function integrates the wheel rotations and uses the omni FK to
        #     estimate a change in position since the start of the program.
        self.enc_curr[2] = msg.data
        if not self.enc_init[2]:
            self.enc_prev[2] = self.enc_curr[2]
            self.enc_init[2] = True

        # num encoder counts / (4 counts / cycle ) / ( 7 * 27 cycles / rev) (2pi rad / rev)
        theta_l = -float(self.enc_curr[0] - self.enc_prev[0]) / 4 / (7 * 27) * (2 * pi)
        theta_b = -float(self.enc_curr[1] - self.enc_prev[1]) / 4 / (7 * 27) * (2 * pi)
        theta_r = -float(self.enc_curr[2] - self.enc_prev[2]) / 4 / (7 * 27) * (2 * pi)


        # v_linear = omega * d / 2
        D1 = theta_l * 0.101 / 2
        D2 = theta_b * 0.101 / 2
        D3 = theta_r * 0.101 / 2

        # Standard transformation from
        delta_x = (2*D2 - D1 - D3) / 3
        delta_y = math.sqrt(3) * (D3 - D1) / 3
        delta_w = (D1 + D2 + D3)/(3 * 0.1905)

        # Element-wise assign or else assigned by reference (very bad)
        self.enc_prev[0] = self.enc_curr[0]
        self.enc_prev[1] = self.enc_curr[1]
        self.enc_prev[2] = self.enc_curr[2]

        self.d_pos_est.x     = delta_x + self.d_pos_est.x
        self.d_pos_est.y     = delta_y + self.d_pos_est.y
        self.d_pos_est.theta = delta_w + self.d_pos_est.theta


    def run(self):
        rate = rospy.Rate(10) # 10 Hz

        while(not rospy.is_shutdown()):
            if ( rospy.get_time() - self.last_command > self.command_timeout):
                self.cmd_vel = [0.0, 0.0, 0.0]

            self.left_pub.publish( self.cmd_vel[0])
            self.back_pub.publish( self.cmd_vel[1])
            self.right_pub.publish(self.cmd_vel[2])
            self.pos_pub.publish(self.d_pos_est)
            rate.sleep()


if __name__ == '__main__':
    vel_command_pub = VelCommander()
    vel_command_pub.run()
