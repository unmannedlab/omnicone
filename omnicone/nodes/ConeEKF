#!/usr/bin/env python

import rospy
import open_base
import math
import numpy as np
from std_msgs.msg import Int32
from geometry_msgs.msg import Twist, Pose2D, Vector3
from omnicone_msgs.msg import ConeState
from ubxtranslator.msg import hpposllh, relpos2D

from math import pi
class ConeEKF:

    def __init__(self):

        rospy.init_node('ConeEKF')

        # Paramters
        self.circumference = pi * 0.101                     # meters
        self.linear_to_rot = 2 * pi / self.circumference    # rad / m
        self.command_timeout = 1.0                          # sec
        self.UBX_error_gain = 20

        # create subscribers
        self.left_enc_sub    = rospy.Subscriber( '/left_joint_velocity_controller/absolute_encoder_count', Int32, self.updateEnc_left)
        self.back_enc_sub    = rospy.Subscriber( '/back_joint_velocity_controller/absolute_encoder_count', Int32, self.updateEnc_back)
        self.right_enc_sub   = rospy.Subscriber('/right_joint_velocity_controller/absolute_encoder_count', Int32, self.predict_step)
        self.UBX_llh_llh_sub = rospy.Subscriber('/UBX/hpposllh', hpposllh, self.update_hpposllh)
        self.UBX_rel_pos_sub = rospy.Subscriber('/UBX/relpos2D', relpos2D, self.update_step)
        self.cone_state_sub  = rospy.Subscriber('/ConeState',   ConeState, self.update_cone_state)

        # create publisher for position estimate
        self.state_pub = rospy.Publisher('EKF/state', Twist, queue_size=10)
        self.state_twist = Twist()

        # set/initialize persistent variables
        self.cone_init = False
        self.enc_init = [False, False, False]
        self.enc_prev = [0.0, 0.0, 0.0]
        self.enc_curr = [0.0, 0.0, 0.0]

        self.state = np.array([[0.0],[0.0],[180.0],[0.0],[0.0],[0.0]])

        self.Process_Q = np.array([ [ 0.0052978353,	 0.0006674407, -0.0994325658,  0.0002413208,  0.0000275520,  0.0695277024],\
                                    [ 0.0006674407,	 0.0003035962, -0.0149129946, -0.0000231930, -0.0000157740,  0.003400838],\
                                    [-0.0994325658,	-0.0149129946,	5.7810347696,  0.0041777458,  0.0050111468,  0.2524022406],\
                                    [ 0.0002413208, -0.0000231930,	0.0041777458,  0.0003084370,  0.0000982770,  0.0157525239],\
                                    [ 0.0000275520,	-0.0000157740,	0.0050111468,  0.0000982770,  0.0001116568,  0.0039943337],\
                                    [ 0.0695277024,  0.0034008380,	0.2524022406,  0.0157525239,  0.0039943337,  8.8239143428]])

        self.state_cov = self.Process_Q

        self.Transition_F = np.array([  [1.0, 0.0, 0.0, 0.2, 0.0, 0.0 ], \
                                        [0.0, 1.0, 0.0, 0.0, 0.2, 0.0 ], \
                                        [0.0, 0.0, 1.0, 0.0, 0.0, 0.2 ], \
                                        [0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ], \
                                        [0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ], \
                                        [0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ]])

        # State Observation Matrix is Constant
        self.Observation_H = np.array([ [1.0, 0.0, 0.0, 0.0, 0.0, 0.0], \
                                        [0.0, 1.0, 0.0, 0.0, 0.0, 0.0], \
                                        [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]])

        self.Kalman_gain_K = np.array([ [1.0, 0.0, 0.0], \
                                        [0.0, 1.0, 0.0], \
                                        [0.0, 0.0, 1.0], \
                                        [0.0, 0.0, 0.0], \
                                        [0.0, 0.0, 0.0], \
                                        [0.0, 0.0, 0.0]])

        self.Observation_cov_R = np.array([ [0.3, 0.0, 0.0], \
                                            [0.0, 0.3, 0.0], \
                                            [0.0, 0.0, 4.0]])

        self.innovation_res_y = np.array([  [0],[0],[0]])

        self.innovation_cov_S = np.array([  [1.0, 0.0, 0.0], \
                                            [0.0, 1.0, 0.0], \
                                            [0.0, 0.0, 1.0]])


    def update_cone_state(self,msg):
        # Cone Initialization Update
        if not self.cone_init and msg.init:
            self.cone_init = True
            self.lon_home = msg.home.x
            self.lat_home = msg.home.y


    def update_hpposllh(self, msg):
        # UBX publisher HPPosLLH Callback
        # Description:
        #     Function updates the internal latitude, longitude, and height for
        #     use with the state calculation.
        #     Additionally, updates the x and y components of the Observation
        #     Covariance Matrix [R]. This value is estimated by the UBX F9P
        #     module.
        self.lon =      msg.llh.lon
        self.lat =      msg.llh.lat
        self.height =   msg.llh.height

        self.Observation_cov_R[0,0] = msg.err.lon * self.UBX_error_gain
        self.Observation_cov_R[1,1] = msg.err.lat * self.UBX_error_gain


    def updateEnc_left(self, msg):
        # Left Motor Encoder Callback
        # Description
        #     Function updates the internal memory of the left encoder counter.
        #     If the variable has not been initialized, the first value is
        #     assigned to both the previous and current encoder value.
        self.enc_curr[0] = msg.data

        # Initialize Encoder Value
        if not self.enc_init[0]:
            self.enc_prev[0] = self.enc_curr[0]
            self.enc_init[0] = True


    def updateEnc_back(self, msg):
        # Back Motor Encoder Callback
        # Description
        #     Function updates the internal memory of the back encoder counter.
        #     If the variable has not been initialized, the first value is
        #     assigned to both the previous and current encoder value.
        self.enc_curr[1] = msg.data

        # Initialize Encoder Value
        if not self.enc_init[1]:
            self.enc_prev[1] = self.enc_curr[1]
            self.enc_init[1] = True


    def predict_step(self, msg):
        # Right Motor Encoder Callback
        # Description
        #     Function updates the internal memory of the right encoder counter.
        #     If the variable has not been initialized, the first value is
        #     assigned to both the previous and current encoder value.
        #     Additionally, function integrates the wheel rotations and uses the
        #     omni base forward kinematics to estimate a change in position. This
        #     estimation is used as the prediction step of the Kalman filter.

        self.enc_curr[2] = msg.data
        # Initialize Encoder Value
        if not self.enc_init[2]:
            self.enc_prev[2] = self.enc_curr[2]
            self.enc_init[2] = True
            self.time_prev = rospy.get_time()

        self.time_curr = rospy.get_time()

        # Determine Rotation Angle of Each Motor
        # num encoder counts / (4 counts / cycle ) / ( 7 * 27 cycles / rev) (2pi rad / rev)
        theta_l = -float(self.enc_curr[0] - self.enc_prev[0]) / 4 / (7 * 27) * (2 * pi)
        theta_b = -float(self.enc_curr[1] - self.enc_prev[1]) / 4 / (7 * 27) * (2 * pi)
        theta_r = -float(self.enc_curr[2] - self.enc_prev[2]) / 4 / (7 * 27) * (2 * pi)

        # Convert Angular to Linear
        # v_linear = omega * d / 2
        D1 = theta_l * 0.101 / 2
        D2 = theta_b * 0.101 / 2
        D3 = theta_r * 0.101 / 2

        # Forward Kinematics Transformation
        delta_x = (2*D2 - D1 - D3) / 3
        delta_y = math.sqrt(3) * (D3 - D1) / 3
        delta_w = -(D1 + D2 + D3)/(3 * 0.1905)

        # Rotation to World Frame
        delta_x_w = -delta_x*math.cos(delta_w/2 + self.state[2]*pi/180) + \
                     delta_y*math.sin(delta_w/2 + self.state[2]*pi/180)
        delta_y_w = -delta_x*math.sin(delta_w/2 + self.state[2]*pi/180) - \
                     delta_y*math.cos(delta_w/2 + self.state[2]*pi/180)

        # Element-wise assign or else assigned by reference (very bad)
        self.enc_prev[0] = self.enc_curr[0]
        self.enc_prev[1] = self.enc_curr[1]
        self.enc_prev[2] = self.enc_curr[2]

        # Predict Position States
        self.state[0] = self.state[0] + delta_x_w
        self.state[1] = self.state[1] + delta_y_w
        self.state[2] = self.state[2] + delta_w   * 180 / pi

        # Predict Velocity States
        self.state[3] = delta_x_w / (self.time_curr - self.time_prev)
        self.state[4] = delta_y_w / (self.time_curr - self.time_prev)
        self.state[5] = delta_w   / (self.time_curr - self.time_prev) * 180 / pi

	self.time_prev = self.time_curr

        # P_k|k-1 = F_k * P_k-1|k-1 * F_k^T + Q_k
        self.state_cov = np.matmul(self.Transition_F, np.matmul(self.state_cov, np.transpose(self.Transition_F))) + self.Process_Q


    def update_step(self, msg):
        # UBX publisher HPPosLLH LLH Callback
        # Description:
        #     Function uses the ellipsoid model of Earth to calculate a 2D
        #     position of the vehicle. This position, in conjunction with the
        #     measurement of the vehicle heading is used in the update step in
        #     the Kalman filter.

        # Update state and observation covariance values
        self.Observation_cov_R[2,2] = msg.err.theta * self.UBX_error_gain

        # Ellipsoidal model calculation of Earth
        a = 6378137.0
        b = 6356752.3142
        R = math.sqrt(( math.pow( math.pow(a,2) * math.cos(self.lat*pi/180), 2)+ \
                        math.pow( math.pow(b,2) * math.sin(self.lat*pi/180), 2))/ \
                       (math.pow( a * math.cos(self.lat*pi/180), 2)+ \
                        math.pow( b * math.sin(self.lat*pi/180), 2))) + self.height

        # Transform LLH to 2D position
        dlon = self.lon - self.lon_home    # degrees
        dlat = self.lat - self.lat_home    # degrees
        dE = R * math.radians(dlon)     # meters
        dN = R * math.radians(dlat)     # meters

        # Measurement in matrix format
        measurement = np.array([[dE],[dN],[msg.pos.theta]])

        # y_k       = z_k - h(xhat_k|k-1)
        self.innovation_res_y = measurement - np.matmul(self.Observation_H, self.state)

        # S_k       = H_k * P_k|k-1 * H_k^T + R_kError
        self.innovation_cov_S = np.matmul(self.Observation_H, np.matmul(self.state_cov, np.transpose(self.Observation_H))) + self.Observation_cov_R

        # K_k       = P_k|k-1 * H_k^T * S_k^-1
        self.Kalman_gain_K = np.matmul(self.state_cov, np.matmul(np.transpose(self.Observation_H), np.linalg.inv(self.innovation_cov_S)))

        # xhat_k|k  = xhat_k|k-1 + K_k * y_k
        self.state = self.state + np.matmul(self.Kalman_gain_K, self.innovation_res_y)

        # P_k|k     = (I - K_k * H_k) * P_k|k-1
        self.state_cov = np.matmul((np.eye(6) - np.matmul(self.Kalman_gain_K, self.Observation_H)), self.state_cov)

    def run(self):
        # State Estimation Publisher
        # Description:
        #     Function transforms state estimate from Kalman filter into Twist
        #     format and publishes at 10 hz. Is not dependent on callbacks.
        #     The twist message components are redefined as Pose2D for
        #     the linear component and Pose2D's derivative as the
        #     angular component.

        rate = rospy.Rate(10) # 10 Hz
        while(not rospy.is_shutdown()):
            self.state_twist.linear.x  = self.state[0]
            self.state_twist.linear.y  = self.state[1]
            self.state_twist.linear.z  = self.state[2]
            self.state_twist.angular.x = self.state[3]
            self.state_twist.angular.y = self.state[4]
            self.state_twist.angular.z = self.state[5]
            self.state_pub.publish( self.state_twist )

            rate.sleep()


if __name__ == '__main__':
    Omnicone_EKF = ConeEKF()
    Omnicone_EKF.run()
