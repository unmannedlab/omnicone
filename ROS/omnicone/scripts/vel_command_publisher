#!/usr/bin/env python
import rospy
import open_base
import math
from std_msgs.msg import Float32, Float64, Int32
from geometry_msgs.msg import Pose2D, Point

from math import pi
from open_base.srv import KinematicsInverse, KinematicsForward

class VelCommander:



    def __init__(self):
        rospy.init_node('vel_command_publisher')
        self.circumference = pi * 0.101                  # meters
        self.linear_to_rot = 2 * pi / self.circumference # rad / m

        # create the publisher for each individual
        self.left_pub  = rospy.Publisher('left_joint_velocity_controller/command' , Float64, queue_size=10)
        self.back_pub  = rospy.Publisher('back_joint_velocity_controller/command' , Float64, queue_size=10)
        self.right_pub = rospy.Publisher('right_joint_velocity_controller/command', Float64, queue_size=10)

        # create the subscriber for the goal velocity
        self.vel_goal_sub = rospy.Subscriber('/robot_vel_goal', Pose2D, self.updateVels)

        # create the subscriber for the encoder_pulses_per_revolution
        self.left_enc_sub  = rospy.Subscriber( '/left_joint_velocity_controller/absolute_encoder_count', Int32, self.updateEnc_left)
        self.back_enc_sub  = rospy.Subscriber( '/back_joint_velocity_controller/absolute_encoder_count', Int32, self.updateEnc_back)
        self.right_enc_sub = rospy.Subscriber('/right_joint_velocity_controller/absolute_encoder_count', Int32, self.updatePos)

        # create publisher for position estimate
        self.pos_pub = rospy.Publisher('pos_estimate',Pose2D, queue_size=10)

        # create the caller to the inverse kinematics server
        self.ik_service_client = rospy.ServiceProxy('/kinematics_inverse_world', KinematicsInverse)
        self.fk_service_client = rospy.ServiceProxy('/kinematics_forward_world', KinematicsForward)

        self.vel_left  = 0.0
        self.vel_back  = 0.0
        self.vel_right = 0.0


        self.left_enc_init  = False
        self.back_enc_init  = False
        self.right_enc_init = False

        self.d_pos_est = Pose2D(0,0,0)

        self.left_enc_prev  = 0
        self.back_enc_prev  = 0
        self.right_enc_prev = 0

        self.left_enc_curr  = 0
        self.back_enc_curr  = 0
        self.right_enc_curr = 0

        self.command_timeout = 1.0

        self.last_command = rospy.get_time()
        self.last_time = rospy.get_time()

    def updateEnc_left(self, msg):
        self.left_enc_curr = msg.data
        if not self.left_enc_init:
            self.left_enc_prev = self.left_enc_curr
            self.left_enc_init = True

    def updateEnc_back(self, msg):
        self.back_enc_curr = msg.data
        if not self.back_enc_init:
            self.back_enc_prev = self.back_enc_curr
            self.back_enc_init = True

    def updateVels(self, goal):
        resp = self.ik_service_client(goal)

        self.vel_left  = -resp.output.v_left  * self.linear_to_rot
        self.vel_back  = -resp.output.v_back  * self.linear_to_rot
        self.vel_right = -resp.output.v_right * self.linear_to_rot

        self.last_command = rospy.Time.now()

    def updatePos(self, msg):
        self.right_enc_curr = msg.data

        if not self.right_enc_init:
            self.right_enc_prev = self.right_enc_curr
            self.right_enc_init = True

        dt = rospy.get_time() - self.last_time
        self.last_time = rospy.get_time()
                # number of encoder counts / (4 counts / cycle ) / ( 7 * 27 cycles / rev) (2pi rad / rev)
        omega_l = float(self.left_enc_curr - self.left_enc_prev ) / 4 / (7 * 27) * (2 * pi)
        omega_b = float(self.back_enc_curr - self.back_enc_prev ) / 4 / (7 * 27) * (2 * pi)
        omega_r = float(self.right_enc_curr- self.right_enc_prev) / 4 / (7 * 27) * (2 * pi)

        V1 = omega_l * 0.101 / 2
        V2 = omega_b * 0.101 / 2
        V3 = omega_r * 0.101 / 2

        Vx = (2*V2 - V1 - V3)/3
        Vy = math.sqrt(3)*(V3 - V1)/3
        W  =(V1+V2+V3)/3/0.1905

        self.left_enc_prev  = self.left_enc_curr
        self.back_enc_prev  = self.back_enc_curr
        self.right_enc_prev = self.right_enc_curr

        self.d_pos_est.x     = Vx + self.d_pos_est.x
        self.d_pos_est.y     = Vy + self.d_pos_est.y
        self.d_pos_est.theta = W  + self.d_pos_est.theta



    def run(self):
        rate = rospy.Rate(10) # 10 Hz

        while(not rospy.is_shutdown()):
            if ( rospy.get_time() - self.last_time > self.command_timeout):
                self.vel_left = 0.0
                self.vel_back = 0.0
                self.vel_right = 0.0



            self.left_pub.publish(self.vel_left)
            self.back_pub.publish(self.vel_back)
            self.right_pub.publish(self.vel_right)
            self.pos_pub.publish(self.d_pos_est)
            rate.sleep()


if __name__ == '__main__':
    vel_command_pub = VelCommander()
    vel_command_pub.run()
